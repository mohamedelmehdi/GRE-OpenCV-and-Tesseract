//
//  GT_API.m
//  GT_API
//
//  Created by xrm on 13-3-30.
//  Copyright (c) 2013年 XuRuomeng. All rights reserved.
//

#import "GT_API.h"
@interface OSDBattery : NSObject
+ (id) sharedInstance;
- (id)_getChargerType;
- (NSString*)_getBatteryID;
- (id)_getBatteryManufacturer;
- (id)_getBatterySerialNumber;
- (BOOL)_deviceIsCharging;
- (BOOL)_exactDeviceChargerConnected;
- (BOOL)_deviceChargerConnected;
- (int)_getRawBatteryVoltage;
- (int)_getBatteryCycleCount;
- (int)_getBatteryDesignCapacity;
- (int)_getBatteryLevel;
- (int)_getChargerID;
- (int)_getChargerCurrent;
- (BOOL)_externalPowerConnected;
- (int)_getBatteryMaxCapacity;
- (int)_getBatteryCurrentCapacity;
- (unsigned int)_getIOPMPowerSourceService;
- (id)_batteryID;
@end

@interface PSSystemConfigurationDynamicStoreWifiWatcher : NSObject{
    struct __SCDynamicStore *_prefs;
    struct __CFString *_wifiKey;
    struct __CFString *_wifiInterface;
    struct __CFString *_tetheringLink;
}
+ (BOOL)wifiEnabled;
+ (void)releaseSharedInstance;
+ (id)sharedInstance;
- (void)dealloc;
- (id)init;
- (id)wifiConfig;
- (id)_wifiNameWithState:(id)arg1;
- (id)_wifiPowerWithState:(id)arg1;
- (id)_wifiTetheringWithState:(id)arg1;
- (void)findKeysAirPortState:(id *)arg1 andTetheringState:(id *)arg2;
@end

@interface UIProgressHUD : NSObject
- (void) show: (BOOL) yesOrNo;
- (UIProgressHUD *) initWithWindow: (UIView *) window;
@end


static const char *kBase64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static const char *kWebSafeBase64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
static const char kBase64PaddingChar = '=';
static const char kBase64InvalidChar = 99;

static const char kBase64DecodeChars[] = {
    // This array was generated by the following code:
    // #include <sys/time.h>
    // #include <stdlib.h>
    // #include <string.h>
    // main()
    // {
    //   static const char Base64[] =
    //     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    //   char *pos;
    //   int idx, i, j;
    //   printf("    ");
    //   for (i = 0; i < 255; i += 8) {
    //     for (j = i; j < i + 8; j++) {
    //       pos = strchr(Base64, j);
    //       if ((pos == NULL) || (j == 0))
    //         idx = 99;
    //       else
    //         idx = pos - Base64;
    //       if (idx == 99)
    //         printf(" %2d,     ", idx);
    //       else
    //         printf(" %2d/*%c*/,", idx, j);
    //     }
    //     printf("\n    ");
    //   }
    // }
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      62/*+*/, 99,      99,      99,      63/*/ */,
    52/*0*/, 53/*1*/, 54/*2*/, 55/*3*/, 56/*4*/, 57/*5*/, 58/*6*/, 59/*7*/,
    60/*8*/, 61/*9*/, 99,      99,      99,      99,      99,      99,
    99,       0/*A*/,  1/*B*/,  2/*C*/,  3/*D*/,  4/*E*/,  5/*F*/,  6/*G*/,
    7/*H*/,  8/*I*/,  9/*J*/, 10/*K*/, 11/*L*/, 12/*M*/, 13/*N*/, 14/*O*/,
    15/*P*/, 16/*Q*/, 17/*R*/, 18/*S*/, 19/*T*/, 20/*U*/, 21/*V*/, 22/*W*/,
    23/*X*/, 24/*Y*/, 25/*Z*/, 99,      99,      99,      99,      99,
    99,      26/*a*/, 27/*b*/, 28/*c*/, 29/*d*/, 30/*e*/, 31/*f*/, 32/*g*/,
    33/*h*/, 34/*i*/, 35/*j*/, 36/*k*/, 37/*l*/, 38/*m*/, 39/*n*/, 40/*o*/,
    41/*p*/, 42/*q*/, 43/*r*/, 44/*s*/, 45/*t*/, 46/*u*/, 47/*v*/, 48/*w*/,
    49/*x*/, 50/*y*/, 51/*z*/, 99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99
};

static const char kWebSafeBase64DecodeChars[] = {
    // This array was generated by the following code:
    // #include <sys/time.h>
    // #include <stdlib.h>
    // #include <string.h>
    // main()
    // {
    //   static const char Base64[] =
    //     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    //   char *pos;
    //   int idx, i, j;
    //   printf("    ");
    //   for (i = 0; i < 255; i += 8) {
    //     for (j = i; j < i + 8; j++) {
    //       pos = strchr(Base64, j);
    //       if ((pos == NULL) || (j == 0))
    //         idx = 99;
    //       else
    //         idx = pos - Base64;
    //       if (idx == 99)
    //         printf(" %2d,     ", idx);
    //       else
    //         printf(" %2d/*%c*/,", idx, j);
    //     }
    //     printf("\n    ");
    //   }
    // }
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      62/*-*/, 99,      99,
    52/*0*/, 53/*1*/, 54/*2*/, 55/*3*/, 56/*4*/, 57/*5*/, 58/*6*/, 59/*7*/,
    60/*8*/, 61/*9*/, 99,      99,      99,      99,      99,      99,
    99,       0/*A*/,  1/*B*/,  2/*C*/,  3/*D*/,  4/*E*/,  5/*F*/,  6/*G*/,
    7/*H*/,  8/*I*/,  9/*J*/, 10/*K*/, 11/*L*/, 12/*M*/, 13/*N*/, 14/*O*/,
    15/*P*/, 16/*Q*/, 17/*R*/, 18/*S*/, 19/*T*/, 20/*U*/, 21/*V*/, 22/*W*/,
    23/*X*/, 24/*Y*/, 25/*Z*/, 99,      99,      99,      99,      63/*_*/,
    99,      26/*a*/, 27/*b*/, 28/*c*/, 29/*d*/, 30/*e*/, 31/*f*/, 32/*g*/,
    33/*h*/, 34/*i*/, 35/*j*/, 36/*k*/, 37/*l*/, 38/*m*/, 39/*n*/, 40/*o*/,
    41/*p*/, 42/*q*/, 43/*r*/, 44/*s*/, 45/*t*/, 46/*u*/, 47/*v*/, 48/*w*/,
    49/*x*/, 50/*y*/, 51/*z*/, 99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99,
    99,      99,      99,      99,      99,      99,      99,      99
};


// Tests a character to see if it's a whitespace character.
//
// Returns:
//   YES if the character is a whitespace character.
//   NO if the character is not a whitespace character.
//
GTM_INLINE BOOL IsSpace(unsigned char c) {
    // we use our own mapping here because we don't want anything w/ locale
    // support.
    static BOOL kSpaces[256] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  // 0-9
        1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  // 10-19
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 20-29
        0, 0, 1, 0, 0, 0, 0, 0, 0, 0,  // 30-39
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 40-49
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 50-59
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 60-69
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 70-79
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 80-89
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 90-99
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 100-109
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 110-119
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 120-129
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 130-139
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 140-149
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 150-159
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 160-169
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 170-179
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 180-189
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 190-199
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 200-209
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 210-219
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 220-229
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 230-239
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // 240-249
        0, 0, 0, 0, 0, 1,              // 250-255
    };
    return kSpaces[c];
}

// Calculate how long the data will be once it's base64 encoded.
//
// Returns:
//   The guessed encoded length for a source length
//
GTM_INLINE NSUInteger CalcEncodedLength(NSUInteger srcLen, BOOL padded) {
    NSUInteger intermediate_result = 8 * srcLen + 5;
    NSUInteger len = intermediate_result / 6;
    if (padded) {
        len = ((len + 3) / 4) * 4;
    }
    return len;
}

// Tries to calculate how long the data will be once it's base64 decoded.
// Unlike the above, this is always an upperbound, since the source data
// could have spaces and might end with the padding characters on them.
//
// Returns:
//   The guessed decoded length for a source length
//
GTM_INLINE NSUInteger GuessDecodedLength(NSUInteger srcLen) {
    return (srcLen + 3) / 4 * 3;
}


@interface GTMBase64 (PrivateMethods)

+(NSData *)baseEncode:(const void *)bytes
               length:(NSUInteger)length
              charset:(const char *)charset
               padded:(BOOL)padded;

+(NSData *)baseDecode:(const void *)bytes
               length:(NSUInteger)length
              charset:(const char*)charset
       requirePadding:(BOOL)requirePadding;

+(NSUInteger)baseEncode:(const char *)srcBytes
                 srcLen:(NSUInteger)srcLen
              destBytes:(char *)destBytes
                destLen:(NSUInteger)destLen
                charset:(const char *)charset
                 padded:(BOOL)padded;

+(NSUInteger)baseDecode:(const char *)srcBytes
                 srcLen:(NSUInteger)srcLen
              destBytes:(char *)destBytes
                destLen:(NSUInteger)destLen
                charset:(const char *)charset
         requirePadding:(BOOL)requirePadding;

@end


@implementation GTMBase64

//
// Standard Base64 (RFC) handling
//

+(NSData *)encodeData:(NSData *)data {
    return [self baseEncode:[data bytes]
                     length:[data length]
                    charset:kBase64EncodeChars
                     padded:YES];
}

+(NSData *)decodeData:(NSData *)data {
    return [self baseDecode:[data bytes]
                     length:[data length]
                    charset:kBase64DecodeChars
             requirePadding:YES];
}

+(NSData *)encodeBytes:(const void *)bytes length:(NSUInteger)length {
    return [self baseEncode:bytes
                     length:length
                    charset:kBase64EncodeChars
                     padded:YES];
}

+(NSData *)decodeBytes:(const void *)bytes length:(NSUInteger)length {
    return [self baseDecode:bytes
                     length:length
                    charset:kBase64DecodeChars
             requirePadding:YES];
}

+(NSString *)stringByEncodingData:(NSData *)data {
    NSString *result = nil;
    NSData *converted = [self baseEncode:[data bytes]
                                  length:[data length]
                                 charset:kBase64EncodeChars
                                  padded:YES];
    if (converted) {
        result = [[NSString alloc] initWithData:converted
                                       encoding:NSASCIIStringEncoding] ;
    }
    return result;
}

+(NSString *)stringByEncodingBytes:(const void *)bytes length:(NSUInteger)length {
    NSString *result = nil;
    NSData *converted = [self baseEncode:bytes
                                  length:length
                                 charset:kBase64EncodeChars
                                  padded:YES];
    if (converted) {
        result = [[NSString alloc] initWithData:converted
                                       encoding:NSASCIIStringEncoding];
    }
    return result;
}

+(NSData *)decodeString:(NSString *)string {
    NSData *result = nil;
    NSData *data = [string dataUsingEncoding:NSASCIIStringEncoding];
    if (data) {
        result = [self baseDecode:[data bytes]
                           length:[data length]
                          charset:kBase64DecodeChars
                   requirePadding:YES];
    }
    return result;
}

//
// Modified Base64 encoding so the results can go onto urls.
//
// The changes are in the characters generated and also the result isn't
// padded to a multiple of 4.
// Must use the matching call to encode/decode, won't interop with the
// RFC versions.
//

+(NSData *)webSafeEncodeData:(NSData *)data
                      padded:(BOOL)padded {
    return [self baseEncode:[data bytes]
                     length:[data length]
                    charset:kWebSafeBase64EncodeChars
                     padded:padded];
}

+(NSData *)webSafeDecodeData:(NSData *)data {
    return [self baseDecode:[data bytes]
                     length:[data length]
                    charset:kWebSafeBase64DecodeChars
             requirePadding:NO];
}

+(NSData *)webSafeEncodeBytes:(const void *)bytes
                       length:(NSUInteger)length
                       padded:(BOOL)padded {
    return [self baseEncode:bytes
                     length:length
                    charset:kWebSafeBase64EncodeChars
                     padded:padded];
}

+(NSData *)webSafeDecodeBytes:(const void *)bytes length:(NSUInteger)length {
    return [self baseDecode:bytes
                     length:length
                    charset:kWebSafeBase64DecodeChars
             requirePadding:NO];
}

+(NSString *)stringByWebSafeEncodingData:(NSData *)data
                                  padded:(BOOL)padded {
    NSString *result = nil;
    NSData *converted = [self baseEncode:[data bytes]
                                  length:[data length]
                                 charset:kWebSafeBase64EncodeChars
                                  padded:padded];
    if (converted) {
        result = [[NSString alloc] initWithData:converted
                                       encoding:NSASCIIStringEncoding];
    }
    return result;
}

+(NSString *)stringByWebSafeEncodingBytes:(const void *)bytes
                                   length:(NSUInteger)length
                                   padded:(BOOL)padded {
    NSString *result = nil;
    NSData *converted = [self baseEncode:bytes
                                  length:length
                                 charset:kWebSafeBase64EncodeChars
                                  padded:padded];
    if (converted) {
        result = [[NSString alloc] initWithData:converted
                                       encoding:NSASCIIStringEncoding];
    }
    return result;
}

+(NSData *)webSafeDecodeString:(NSString *)string {
    NSData *result = nil;
    NSData *data = [string dataUsingEncoding:NSASCIIStringEncoding];
    if (data) {
        result = [self baseDecode:[data bytes]
                           length:[data length]
                          charset:kWebSafeBase64DecodeChars
                   requirePadding:NO];
    }
    return result;
}

@end

@implementation GTMBase64 (PrivateMethods)

//
// baseEncode:length:charset:padded:
//
// Does the common lifting of creating the dest NSData.  it creates & sizes the
// data for the results.  |charset| is the characters to use for the encoding
// of the data.  |padding| controls if the encoded data should be padded to a
// multiple of 4.
//
// Returns:
//   an autorelease NSData with the encoded data, nil if any error.
//
+(NSData *)baseEncode:(const void *)bytes
               length:(NSUInteger)length
              charset:(const char *)charset
               padded:(BOOL)padded {
    // how big could it be?
    NSUInteger maxLength = CalcEncodedLength(length, padded);
    // make space
    NSMutableData *result = [NSMutableData data];
    [result setLength:maxLength];
    // do it
    NSUInteger finalLength = [self baseEncode:bytes
                                       srcLen:length
                                    destBytes:[result mutableBytes]
                                      destLen:[result length]
                                      charset:charset
                                       padded:padded];
    if (finalLength) {
        _GTMDevAssert(finalLength == maxLength, @"how did we calc the length wrong?");
    } else {
        // shouldn't happen, this means we ran out of space
        result = nil;
    }
    return result;
}

//
// baseDecode:length:charset:requirePadding:
//
// Does the common lifting of creating the dest NSData.  it creates & sizes the
// data for the results.  |charset| is the characters to use for the decoding
// of the data.
//
// Returns:
//   an autorelease NSData with the decoded data, nil if any error.
//
//
+(NSData *)baseDecode:(const void *)bytes
               length:(NSUInteger)length
              charset:(const char *)charset
       requirePadding:(BOOL)requirePadding {
    // could try to calculate what it will end up as
    NSUInteger maxLength = GuessDecodedLength(length);
    // make space
    NSMutableData *result = [NSMutableData data];
    [result setLength:maxLength];
    // do it
    NSUInteger finalLength = [self baseDecode:bytes
                                       srcLen:length
                                    destBytes:[result mutableBytes]
                                      destLen:[result length]
                                      charset:charset
                               requirePadding:requirePadding];
    if (finalLength) {
        if (finalLength != maxLength) {
            // resize down to how big it was
            [result setLength:finalLength];
        }
    } else {
        // either an error in the args, or we ran out of space
        result = nil;
    }
    return result;
}

//
// baseEncode:srcLen:destBytes:destLen:charset:padded:
//
// Encodes the buffer into the larger.  returns the length of the encoded
// data, or zero for an error.
// |charset| is the characters to use for the encoding
// |padded| tells if the result should be padded to a multiple of 4.
//
// Returns:
//   the length of the encoded data.  zero if any error.
//
+(NSUInteger)baseEncode:(const char *)srcBytes
                 srcLen:(NSUInteger)srcLen
              destBytes:(char *)destBytes
                destLen:(NSUInteger)destLen
                charset:(const char *)charset
                 padded:(BOOL)padded {
    if (!srcLen || !destLen || !srcBytes || !destBytes) {
        return 0;
    }
    
    char *curDest = destBytes;
    const unsigned char *curSrc = (const unsigned char *)(srcBytes);
    
    // Three bytes of data encodes to four characters of cyphertext.
    // So we can pump through three-byte chunks atomically.
    while (srcLen > 2) {
        // space?
        _GTMDevAssert(destLen >= 4, @"our calc for encoded length was wrong");
        curDest[0] = charset[curSrc[0] >> 2];
        curDest[1] = charset[((curSrc[0] & 0x03) << 4) + (curSrc[1] >> 4)];
        curDest[2] = charset[((curSrc[1] & 0x0f) << 2) + (curSrc[2] >> 6)];
        curDest[3] = charset[curSrc[2] & 0x3f];
        
        curDest += 4;
        curSrc += 3;
        srcLen -= 3;
        destLen -= 4;
    }
    
    // now deal with the tail (<=2 bytes)
    switch (srcLen) {
        case 0:
            // Nothing left; nothing more to do.
            break;
        case 1:
            // One byte left: this encodes to two characters, and (optionally)
            // two pad characters to round out the four-character cypherblock.
            _GTMDevAssert(destLen >= 2, @"our calc for encoded length was wrong");
            curDest[0] = charset[curSrc[0] >> 2];
            curDest[1] = charset[(curSrc[0] & 0x03) << 4];
            curDest += 2;
            destLen -= 2;
            if (padded) {
                _GTMDevAssert(destLen >= 2, @"our calc for encoded length was wrong");
                curDest[0] = kBase64PaddingChar;
                curDest[1] = kBase64PaddingChar;
                curDest += 2;
            }
            break;
        case 2:
            // Two bytes left: this encodes to three characters, and (optionally)
            // one pad character to round out the four-character cypherblock.
            _GTMDevAssert(destLen >= 3, @"our calc for encoded length was wrong");
            curDest[0] = charset[curSrc[0] >> 2];
            curDest[1] = charset[((curSrc[0] & 0x03) << 4) + (curSrc[1] >> 4)];
            curDest[2] = charset[(curSrc[1] & 0x0f) << 2];
            curDest += 3;
            destLen -= 3;
            if (padded) {
                _GTMDevAssert(destLen >= 1, @"our calc for encoded length was wrong");
                curDest[0] = kBase64PaddingChar;
                curDest += 1;
            }
            break;
    }
    // return the length
    return (curDest - destBytes);
}

//
// baseDecode:srcLen:destBytes:destLen:charset:requirePadding:
//
// Decodes the buffer into the larger.  returns the length of the decoded
// data, or zero for an error.
// |charset| is the character decoding buffer to use
//
// Returns:
//   the length of the encoded data.  zero if any error.
//
+(NSUInteger)baseDecode:(const char *)srcBytes
                 srcLen:(NSUInteger)srcLen
              destBytes:(char *)destBytes
                destLen:(NSUInteger)destLen
                charset:(const char *)charset
         requirePadding:(BOOL)requirePadding {
    if (!srcLen || !destLen || !srcBytes || !destBytes) {
        return 0;
    }
    
    int decode;
    NSUInteger destIndex = 0;
    int state = 0;
    char ch = 0;
    while (srcLen-- && (ch = *srcBytes++) != 0)  {
        if (IsSpace(ch))  // Skip whitespace
            continue;
        
        if (ch == kBase64PaddingChar)
            break;
        
        decode = charset[(unsigned int)ch];
        if (decode == kBase64InvalidChar)
            return 0;
        
        // Four cyphertext characters decode to three bytes.
        // Therefore we can be in one of four states.
        switch (state) {
            case 0:
                // We're at the beginning of a four-character cyphertext block.
                // This sets the high six bits of the first byte of the
                // plaintext block.
                _GTMDevAssert(destIndex < destLen, @"our calc for decoded length was wrong");
                destBytes[destIndex] = decode << 2;
                state = 1;
                break;
            case 1:
                // We're one character into a four-character cyphertext block.
                // This sets the low two bits of the first plaintext byte,
                // and the high four bits of the second plaintext byte.
                _GTMDevAssert((destIndex+1) < destLen, @"our calc for decoded length was wrong");
                destBytes[destIndex] |= decode >> 4;
                destBytes[destIndex+1] = (decode & 0x0f) << 4;
                destIndex++;
                state = 2;
                break;
            case 2:
                // We're two characters into a four-character cyphertext block.
                // This sets the low four bits of the second plaintext
                // byte, and the high two bits of the third plaintext byte.
                // However, if this is the end of data, and those two
                // bits are zero, it could be that those two bits are
                // leftovers from the encoding of data that had a length
                // of two mod three.
                _GTMDevAssert((destIndex+1) < destLen, @"our calc for decoded length was wrong");
                destBytes[destIndex] |= decode >> 2;
                destBytes[destIndex+1] = (decode & 0x03) << 6;
                destIndex++;
                state = 3;
                break;
            case 3:
                // We're at the last character of a four-character cyphertext block.
                // This sets the low six bits of the third plaintext byte.
                _GTMDevAssert(destIndex < destLen, @"our calc for decoded length was wrong");
                destBytes[destIndex] |= decode;
                destIndex++;
                state = 0;
                break;
        }
    }
    
    // We are done decoding Base-64 chars.  Let's see if we ended
    //      on a byte boundary, and/or with erroneous trailing characters.
    if (ch == kBase64PaddingChar) {               // We got a pad char
        if ((state == 0) || (state == 1)) {
            return 0;  // Invalid '=' in first or second position
        }
        if (srcLen == 0) {
            if (state == 2) { // We run out of input but we still need another '='
                return 0;
            }
            // Otherwise, we are in state 3 and only need this '='
        } else {
            if (state == 2) {  // need another '='
                while ((ch = *srcBytes++) && (srcLen-- > 0)) {
                    if (!IsSpace(ch))
                        break;
                }
                if (ch != kBase64PaddingChar) {
                    return 0;
                }
            }
            // state = 1 or 2, check if all remain padding is space
            while ((ch = *srcBytes++) && (srcLen-- > 0)) {
                if (!IsSpace(ch)) {
                    return 0;
                }
            }
        }
    } else {
        // We ended by seeing the end of the string.
        
        if (requirePadding) {
            // If we require padding, then anything but state 0 is an error.
            if (state != 0) {
                return 0;
            }
        } else {
            // Make sure we have no partial bytes lying around.  Note that we do not
            // require trailing '=', so states 2 and 3 are okay too.
            if (state == 1) {
                return 0;
            }
        }
    }
    
    // If then next piece of output was valid and got written to it means we got a
    // very carefully crafted input that appeared valid but contains some trailing
    // bits past the real length, so just toss the thing.
    if ((destIndex < destLen) &&
        (destBytes[destIndex] != 0)) {
        return 0;
    }
    
    return destIndex;
}

@end


@implementation NSData (Encryption)

- (NSData *)AES256EncryptWithKey:(NSString *)key {//加密
    char keyPtr[kCCKeySizeAES256+1];
    bzero(keyPtr, sizeof(keyPtr));
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [self length];
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);
    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128,
                                          kCCOptionPKCS7Padding | kCCOptionECBMode,
                                          keyPtr, kCCBlockSizeAES128,
                                          NULL,
                                          [self bytes], dataLength,
                                          buffer, bufferSize,
                                          &numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    }
    free(buffer);
    return nil;
}


- (NSData *)AES256DecryptWithKey:(NSString *)key {//解密
    char keyPtr[kCCKeySizeAES256+1];
    bzero(keyPtr, sizeof(keyPtr));
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [self length];
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);
    size_t numBytesDecrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128,
                                          kCCOptionPKCS7Padding | kCCOptionECBMode,
                                          keyPtr, kCCBlockSizeAES128,
                                          NULL,
                                          [self bytes], dataLength,
                                          buffer, bufferSize,
                                          &numBytesDecrypted);
    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
    }
    free(buffer);
    return nil;
}

@end

@implementation NSString (MD5)

- (NSString *)md5Encrypt {
    const char *cStr = [self UTF8String];
    unsigned char result[16];
    CC_MD5( cStr, strlen(cStr), result );
    return [NSString stringWithFormat:@"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
            result[0], result[1], result[2], result[3],
            result[4], result[5], result[6], result[7],
            result[8], result[9], result[10], result[11],
            result[12], result[13], result[14], result[15]
            ];
}

@end
/*
 #define	HW_MACHINE
 #define	HW_MODEL
 #define	HW_NCPU
 #define	HW_BYTEORDER
 #define	HW_PHYSMEM
 #define	HW_USERMEM
 #define	HW_PAGESIZE
 #define	HW_DISKNAMES
 #define	HW_DISKSTATS
 #define	HW_EPOCH
 #define HW_FLOATINGPT
 #define HW_MACHINE_ARCH
 #define HW_VECTORUNIT
 #define HW_BUS_FREQ
 #define HW_CPU_FREQ
 #define HW_CACHELINE
 #define HW_L1ICACHESIZE
 #define HW_L1DCACHESIZE
 #define HW_L2SETTINGS
 #define HW_L2CACHESIZE
 #define HW_L3SETTINGS	21
 #define HW_L3CACHESIZE	22
 #define HW_TB_FREQ
 #define HW_MEMSIZE
 #define HW_AVAILCPU
 #define	HW_MAXID
 */


@implementation GT_API
+ (NSDate *)boottime_NSDate_UTC{
    struct tm *p;
    struct timeval boottime;
    int mib[2] = {CTL_KERN, KERN_BOOTTIME};
    size_t size = sizeof(boottime);
    time_t now;
    time_t uptime = -1;
    (void)time(&now);
    
    if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1 && boottime.tv_sec != 0)
    {
        uptime = boottime.tv_sec;
    }
    p = gmtime(&uptime);
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateStyle:NSDateFormatterMediumStyle];
    [formatter setTimeStyle:NSDateFormatterShortStyle];
    [formatter setDateFormat:@"YYYY/MM/dd HH:mm:ss"];
    NSDate* date1 = [formatter dateFromString:[NSString stringWithFormat:@"%d/%d/%d %d:%d:%d",1900+p->tm_year,1 + p->tm_mon,p->tm_mday,p->tm_hour,p->tm_min,p->tm_sec]];
    return date1;
}
+ (NSUInteger)boottime_UnixPOISX_UTC{
    struct timeval boottime;
    int mib[2] = {CTL_KERN, KERN_BOOTTIME};
    size_t size = sizeof(boottime);
    time_t now;
    time_t uptime = -1;
    
    (void)time(&now);
    
    if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1 && boottime.tv_sec != 0)
    {
        uptime = boottime.tv_sec;
    }
    NSUInteger time = [[NSString stringWithFormat:@"%ld",uptime] integerValue];
    return time;
}
+ (NSUInteger)uptime_RealSeconds{
    struct timeval boottime;
    int mib[2] = {CTL_KERN, KERN_BOOTTIME};
    size_t size = sizeof(boottime);
    time_t now;
    time_t uptime = -1;
    
    (void)time(&now);
    
    if (sysctl(mib, 2, &boottime, &size, NULL, 0) != -1 && boottime.tv_sec != 0)
    {
        uptime = now - boottime.tv_sec;
    }
    NSUInteger time = [[NSString stringWithFormat:@"%ld",uptime] integerValue];
    return time;
}
+ (NSUInteger)timebaseFrequency{
    return (NSUInteger)[self getSysInfo:HW_TB_FREQ];
}
+ (NSUInteger)CPU_L2_CacheSize{
    NSLog(@"%@",[self boottime_NSDate_UTC]);
    return (NSUInteger)[self getSysInfo:HW_L2CACHESIZE];
}
+ (NSUInteger)CPU_L3_CacheSize{
    return (NSUInteger)[self getSysInfo:HW_L3CACHESIZE];
}
+ (NSUInteger)CPU_L1_D_CacheSize{
    return (NSUInteger)[self getSysInfo:HW_L1DCACHESIZE];
}
+ (NSUInteger)CPU_L1_I_CacheSize{
    return (NSUInteger)[self getSysInfo:HW_L1ICACHESIZE];
}
+ (NSString *)WiFiMacAddress
{
    int                    mib[6];
    size_t                len;
    char                *buf;
    unsigned char        *ptr;
    struct if_msghdr    *ifm;
    struct sockaddr_dl    *sdl;
    
    mib[0] = CTL_NET;
    mib[1] = AF_ROUTE;
    mib[2] = 0;
    mib[3] = AF_LINK;
    mib[4] = NET_RT_IFLIST;
    
    if ((mib[5] = if_nametoindex("en0")) == 0) {
        printf("Error: if_nametoindex error\n");
        return NULL;
    }
    
    if (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 1\n");
        return NULL;
    }
    
    if ((buf = malloc(len)) == NULL) {
        printf("Could not allocate memory. error!\n");
        return NULL;
    }
    
    if (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {
        printf("Error: sysctl, take 2");
        return NULL;
    }
    
    ifm = (struct if_msghdr *)buf;
    sdl = (struct sockaddr_dl *)(ifm + 1);
    ptr = (unsigned char *)LLADDR(sdl);
    NSMutableString *outstring = [[NSMutableString alloc] init];
    [outstring appendFormat:@"%02x",*ptr];
    [outstring appendFormat:@":"];
    [outstring appendFormat:@"%02x",*(ptr + 1)];
    [outstring appendFormat:@":"];
    [outstring appendFormat:@"%02x",*(ptr + 2)];
    [outstring appendFormat:@":"];
    [outstring appendFormat:@"%02x",*(ptr + 3)];
    [outstring appendFormat:@":"];
    [outstring appendFormat:@"%02x",*(ptr + 4)];
    [outstring appendFormat:@":"];
    [outstring appendFormat:@"%02x",*(ptr + 5)];
    free(buf);
    return [outstring uppercaseString];
}
+ (NSUInteger)memoryInactive{
    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;
    vm_statistics_data_t vmstat;
    if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS)
    {
        return -1;
    }
    else
    {
        return vmstat.inactive_count;
    }
}
+ (NSUInteger)memoryActive{
    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;
    vm_statistics_data_t vmstat;
    if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS)
    {
        return -1;
    }
    else
    {
        return vmstat.active_count;
    }
}
+ (NSUInteger)memoryWire{
    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;
    vm_statistics_data_t vmstat;
    if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS)
    {
        return -1;
    }
    else
    {
        return vmstat.wire_count;
    }
}
+ (NSUInteger)CPUFrequencyNow{
    return [self getSysInfo:HW_CPU_FREQ];
}
+ (NSUInteger)BUSFrequency{
    return [self getSysInfo:HW_BUS_FREQ];
}
+ (void)turnOnInternetTethering{
    WirelessModemController *wirelessModemController;
    NSBundle *bundle = [NSBundle bundleWithPath:@"/System/Library/PreferenceBundles/WirelessModemSettings.bundle"];
    [bundle load];
    Class cls = objc_getClass("WirelessModemController");
    wirelessModemController = [[cls alloc] init];
    [wirelessModemController setInternetTethering:[NSNumber numberWithBool:YES] specifier:nil];
}
+ (NSString *)WWANIPAddress{
    NSString *result = nil;
    struct ifaddrs *interfaces;
    char str[INET_ADDRSTRLEN];
    if (getifaddrs(&interfaces))
        return nil;
    struct ifaddrs *test_addr = interfaces;
    while (test_addr) {
        if(test_addr->ifa_addr->sa_family == AF_INET) {
            if (strcmp(test_addr->ifa_name, "pdp_ip0") == 0) {
                inet_ntop(AF_INET, &((struct sockaddr_in *)test_addr->ifa_addr)->sin_addr, str, INET_ADDRSTRLEN);
                result = [NSString stringWithUTF8String:str];
                break;
            }
        }
        test_addr = test_addr->ifa_next;
    }
    freeifaddrs(interfaces);
    return result;
}
+ (NSString *)WiFiIPAddress{
    NSString *result = nil;
    struct ifaddrs *interfaces;
    char str[INET_ADDRSTRLEN];
    if (getifaddrs(&interfaces))
        return nil;
    struct ifaddrs *test_addr = interfaces;
    while (test_addr) {
        if(test_addr->ifa_addr->sa_family == AF_INET) {
            if (strcmp(test_addr->ifa_name, "en0") == 0) {
                inet_ntop(AF_INET, &((struct sockaddr_in *)test_addr->ifa_addr)->sin_addr, str, INET_ADDRSTRLEN);
                result = [NSString stringWithUTF8String:str];
                break;
            }
        }
        test_addr = test_addr->ifa_next;
    }
    freeifaddrs(interfaces);
    return result;
}
+ (NSString *)WiFiBSSID{
    return [[[super alloc] wifiInfo] valueForKey:@"BSSID"];
}
+ (NSInteger)WiFiChannel{
    return [[[[[super alloc] wifiInfo] valueForKey:@"CHANNEL"] objectForKey:@"CHANNEL"] integerValue];
}
+ (NSInteger)WiFiSignalStrength{
    return [[[[super alloc] wifiInfo] valueForKey:@"RATE"] integerValue];
}
- (NSDictionary *)wifiInfo{
    libHandle = dlopen("/System/Library/SystemConfiguration/IPConfiguration.bundle/IPConfiguration", RTLD_LAZY);
    
    char *error;
    
    if (libHandle == NULL && (error = dlerror()) != NULL)  {
        NSLog(@"%s", error);
        exit(1);
    }
    
    apple80211Open = dlsym(libHandle, "Apple80211Open");
    apple80211Bind = dlsym(libHandle, "Apple80211BindToInterface");
    apple80211Close = dlsym(libHandle, "Apple80211Close");
    apple80211GetInfoCopy = dlsym(libHandle, "Apple80211GetInfoCopy");
    
    apple80211Open(&airportHandle);
    apple80211Bind(airportHandle, @"en0");
    
    CFDictionaryRef info = NULL;
    
    apple80211GetInfoCopy(airportHandle, &info);
    
    apple80211Close(airportHandle);
    
    return (__bridge NSDictionary *)info;
}
+ (BOOL)setBadge:(NSInteger)badge ForApplication:(NSString *)application{
    NSMutableDictionary *applicationStatus = [[NSMutableDictionary alloc] initWithContentsOfFile:@"/var/mobile/Library/SpringBoard/applicationstate.plist"];
    NSLog(@"%@",applicationStatus);
    return NO;
}
+ (NSInteger)getCurrentCallCount{
    void *libHandle = dlopen("/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony", RTLD_LAZY);
    int (*CTGetCurrentCallCount)();
    CTGetCurrentCallCount = dlsym(libHandle, "CTGetCurrentCallCount");
    if( CTGetCurrentCallCount == NULL) NSLog(@"Could not find CTCurrentCallCount");
    int result = CTGetCurrentCallCount();
    dlclose(libHandle);
    return result;
}

+ (NSInteger)getSignalStrength{
    void *libHandle = dlopen("/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony", RTLD_LAZY);
    int (*CTGetSignalStrength)();
    CTGetSignalStrength = dlsym(libHandle, "CTGetSignalStrength");
    if( CTGetSignalStrength == NULL) NSLog(@"Could not find CTGetSignalStrength");
    int result = CTGetSignalStrength();
    dlclose(libHandle);
    return result;
}
+ (void)resetDataCounter{
    //
    void *libHandle = dlopen("/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony", RTLD_LAZY);
    //
    int (*CTRegistrationDataCounterReset)();
    //
    CTRegistrationDataCounterReset = dlsym(libHandle, "CTRegistrationDataCounterReset");
    if(CTRegistrationDataCounterReset == NULL) NSLog(@"Could not find");
    //
    CTRegistrationDataCounterReset();
    dlclose(libHandle);
}
+ (BOOL)getDataContextActive{
    //
    void *libHandle = dlopen("/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony", RTLD_LAZY);
    //
    int (*CTRegistrationGetDataContextActive)();
    //
    CTRegistrationGetDataContextActive = dlsym(libHandle, "CTRegistrationGetDataContextActive");
    if( CTRegistrationGetDataContextActive == NULL) NSLog(@"Could not find");
    //
    BOOL result = (BOOL)CTRegistrationGetDataContextActive(nil);
    dlclose(libHandle);
    return result;
}
+ (uint32_t)dylibCount{
    return _dyld_image_count();
}
+ (NSArray *)dylibPaths{
    NSMutableArray *dylibPaths = [[NSMutableArray alloc] init];
    uint32_t count = _dyld_image_count();
    for(uint32_t i = 0; i < count; i++){
        const char *dyld = _dyld_get_image_name(i);
        int slength = strlen(dyld);
        int j;
        for(j = slength - 1; j>= 0; --j)
            if(dyld[j] == '/') break;
        [dylibPaths addObject:[NSString stringWithFormat:@"%s",dyld]];
    }
    return dylibPaths;
}
+ (NSString*)encodeMD5String:(NSString*)string {
    return [string md5Encrypt];
}
+(NSString*)decodeAESData:(NSData*)data WithKey:(NSString *)keyString{
    NSData *decryData = [data AES256DecryptWithKey:keyString];
    NSString *string = [[NSString alloc] initWithData:decryData encoding:NSUTF8StringEncoding];
    return string;
}
+(NSData*)encodeAESData:(NSString*)string WithKey:(NSString *)keyString{
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    NSData *encryptedData = [data AES256EncryptWithKey:keyString];
    return encryptedData;
}
+ (NSString*)encodeBase64String:(NSString * )input {
    NSData *data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
    data = [GTMBase64 encodeData:data];
    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
	return base64String;
}
+ (NSString*)decodeBase64String:(NSString * )input {
    NSData *data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
    data = [GTMBase64 decodeData:data];
    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
	return base64String;
}
+ (NSString*)encodeBase64Data:(NSData *)data {
	data = [GTMBase64 encodeData:data];
    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
	return base64String;
}
+ (NSString*)decodeBase64Data:(NSData *)data {
	data = [GTMBase64 decodeData:data];
    NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
	return base64String;
}
+(BOOL)checkEmail:(NSString *)email{
    NSString *emailRegex = @"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}";
    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", emailRegex];
    return [emailTest evaluateWithObject:email];
}
+ (void)showProgressHUDWithLastTime:(CGFloat)time Text:(NSString *)text View:(UIView *)view{
    id HUD  = [[UIProgressHUD alloc] initWithWindow:view];
    [HUD setText:text];
    [HUD show:YES];
    [self performSelector:@selector(killHUD:) withObject:HUD afterDelay:time];
}

+ (UIProgressHUD *)showProgressHUDWithText:(NSString *)text View:(UIView *)view{
    id HUD  = [[UIProgressHUD alloc] initWithWindow:view];
    [HUD setText:text];
    [HUD show:YES];
    return HUD;
}

+ (void)killHUD:(id)aHUD{
    [aHUD show:NO];
}

+ (BOOL)checkCreditCardNumber:(NSString *)cardNum
{
    if ([cardNum length] == 0) {
        return NO;
    }
    NSInteger len = [cardNum length];
    NSInteger sumNumOdd = 0;
    NSInteger sumNumEven = 0;
    BOOL isOdd = YES;
    
    for (NSInteger i = len - 1; i >= 0; i--) {
        
        NSInteger num = [cardNum substringWithRange:NSMakeRange(i, 1)].integerValue;
        if (isOdd) {
            sumNumOdd += num;
        }else{
            num = num * 2;
            if (num > 9) {
                num = num - 9;
            }
            sumNumEven += num;
        }
        isOdd = !isOdd;
    }
    return ((sumNumOdd + sumNumEven) % 10 == 0);
}
+ (void)setBrightness:(CGFloat)brightness{
    [[UIScreen mainScreen] setBrightness: brightness];
}
+ (NSString *)WiFiName{
    NSBundle *b = [NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/Preferences.framework"];
    BOOL success = [b load];
    
    if (success) {
        Class PSSystemConfigurationDynamicStoreWifiWatcher = NSClassFromString(@"PSSystemConfigurationDynamicStoreWifiWatcher");
        id tt = [PSSystemConfigurationDynamicStoreWifiWatcher sharedInstance];
        NSDictionary *wifi = [[NSDictionary alloc] init];
        wifi = [tt wifiConfig];
        [PSSystemConfigurationDynamicStoreWifiWatcher releaseSharedInstance];
        return [wifi objectForKey:@"wifiName"];
    }else{
        return nil;
    }
}
+ (BOOL)WiFiEnabled{
    NSBundle *b = [NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/Preferences.framework"];
    BOOL success = [b load];
    
    if (success) {
        Class PSSystemConfigurationDynamicStoreWifiWatcher = NSClassFromString(@"PSSystemConfigurationDynamicStoreWifiWatcher");
        return [PSSystemConfigurationDynamicStoreWifiWatcher wifiEnabled];
    }else{
        return NO;
    }
}
+ (CGFloat)DiskWriteSpeed{
    mach_timebase_info_data_t info;
    if (mach_timebase_info(&info) != KERN_SUCCESS) return -1.0;
    
    uint64_t start = mach_absolute_time ();
    
    uint64_t end = mach_absolute_time ();
    uint64_t elapsed = end - start;
    uint64_t nanos = elapsed * info.numer / info.denom;
    return (CGFloat)nanos / NSEC_PER_SEC;
}
+(NSArray *)runningProcesses
{
	int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL ,0};
    size_t miblen = 4;
    size_t size;
    int st = sysctl(mib, miblen, NULL, &size, NULL, 0);
    
    struct kinfo_proc * process = NULL;
    struct kinfo_proc * newprocess = NULL;
    do
	{
		size += size / 10;
        newprocess = realloc(process, size);
        if (!newprocess)
		{
			if (process)
			{
                free(process);
				process = NULL;
            }
            return nil;
        }
        process = newprocess;
        st = sysctl(mib, miblen, process, &size, NULL, 0);
        
    }
    while (st == -1 && errno == ENOMEM);
    if (st == 0)
	{
        if (size % sizeof(struct kinfo_proc) == 0)
		{
            int nprocess = size / sizeof(struct kinfo_proc);
            if (nprocess)
			{
                NSMutableArray * array = [[NSMutableArray alloc] init];
                for (int i = nprocess - 1; i >= 0; i--)
				{
					NSString * processID = [[NSString alloc] initWithFormat:@"%d", process[i].kp_proc.p_pid];
                    NSString * processName = [[NSString alloc] initWithFormat:@"%s", process[i].kp_proc.p_comm];
					NSString * proc_CPU = [[NSString alloc] initWithFormat:@"%d", process[i].kp_proc.p_pctcpu];
                    
					NSString * proc_useTime = [[NSString alloc] initWithFormat:@"%s",asctime(localtime(&(process[i].kp_proc.p_un.__p_starttime.tv_sec)))];
					NSMutableDictionary *dic = [[NSMutableDictionary alloc] init];
					[dic setValue:processID forKey:@"ProcessID"];
					[dic setValue:processName forKey:@"ProcessName"];
					[dic setValue:proc_CPU forKey:@"ProcessCPU"];
					[dic setValue:proc_useTime forKey:@"ProcessUseTime"];
                    [array addObject:dic];
                    
                }
                free(process);
				process = NULL;
				return array;
                
            }
        }
    }
    return nil;
}
+(uint32_t)networkOutputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t iBytes     = 0;
    uint32_t oBytes     = 0;
    uint32_t allFlow    = 0;
    uint32_t wifiIBytes = 0;
    uint32_t wifiOBytes = 0;
    uint32_t wifiFlow   = 0;
    uint32_t wwanIBytes = 0;
    uint32_t wwanOBytes = 0;
    uint32_t wwanFlow   = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        // Not a loopback device.
        // network flow
        if (strncmp(ifa->ifa_name, "lo", 2))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            iBytes += if_data->ifi_ibytes;
            oBytes += if_data->ifi_obytes;
            allFlow = iBytes + oBytes;
        }
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiIBytes += if_data->ifi_ibytes;
            wifiOBytes += if_data->ifi_obytes;
            wifiFlow    = wifiIBytes + wifiOBytes;
        }
        
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanIBytes += if_data->ifi_ibytes;
            wwanOBytes += if_data->ifi_obytes;
            wwanFlow    = wwanIBytes + wwanOBytes;
        }
    }
    freeifaddrs(ifa_list);
    return oBytes;
}
+(uint32_t)networkInputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t iBytes     = 0;
    uint32_t oBytes     = 0;
    uint32_t allFlow    = 0;
    uint32_t wifiIBytes = 0;
    uint32_t wifiOBytes = 0;
    uint32_t wifiFlow   = 0;
    uint32_t wwanIBytes = 0;
    uint32_t wwanOBytes = 0;
    uint32_t wwanFlow   = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        // Not a loopback device.
        // network flow
        if (strncmp(ifa->ifa_name, "lo", 2))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            iBytes += if_data->ifi_ibytes;
            oBytes += if_data->ifi_obytes;
            allFlow = iBytes + oBytes;
        }
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiIBytes += if_data->ifi_ibytes;
            wifiOBytes += if_data->ifi_obytes;
            wifiFlow    = wifiIBytes + wifiOBytes;
        }
        
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanIBytes += if_data->ifi_ibytes;
            wwanOBytes += if_data->ifi_obytes;
            wwanFlow    = wwanIBytes + wwanOBytes;
        }
    }
    freeifaddrs(ifa_list);
    return iBytes;
}
+(uint32_t)networkAllFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t iBytes     = 0;
    uint32_t oBytes     = 0;
    uint32_t allFlow    = 0;
    uint32_t wifiIBytes = 0;
    uint32_t wifiOBytes = 0;
    uint32_t wifiFlow   = 0;
    uint32_t wwanIBytes = 0;
    uint32_t wwanOBytes = 0;
    uint32_t wwanFlow   = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        // Not a loopback device.
        // network flow
        if (strncmp(ifa->ifa_name, "lo", 2))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            iBytes += if_data->ifi_ibytes;
            oBytes += if_data->ifi_obytes;
            allFlow = iBytes + oBytes;
        }
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiIBytes += if_data->ifi_ibytes;
            wifiOBytes += if_data->ifi_obytes;
            wifiFlow    = wifiIBytes + wifiOBytes;
        }
        
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanIBytes += if_data->ifi_ibytes;
            wwanOBytes += if_data->ifi_obytes;
            wwanFlow    = wwanIBytes + wwanOBytes;
        }
    }
    freeifaddrs(ifa_list);
    return allFlow;
}
+(uint32_t)wwanOutputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t wwanOBytes = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanOBytes += if_data->ifi_obytes;
        }
    }
    freeifaddrs(ifa_list);
    return wwanOBytes;
}
+(uint32_t)wwanInputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t wwanIBytes = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanIBytes += if_data->ifi_ibytes;
        }
    }
    freeifaddrs(ifa_list);
    return wwanIBytes;
}
+(uint32_t)wwanAllFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t wwanFlow   = 0;
    uint32_t wwanIBytes = 0;
    uint32_t wwanOBytes = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        //3G and gprs flow
        if (!strcmp(ifa->ifa_name, "pdp_ip0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wwanIBytes += if_data->ifi_ibytes;
            wwanOBytes += if_data->ifi_obytes;
            wwanFlow    = wwanIBytes + wwanOBytes;
        }
    }
    freeifaddrs(ifa_list);
    return wwanFlow;
}
+(uint32_t)WiFiOutputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t wifiOBytes = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiOBytes += if_data->ifi_obytes;
        }
        
    }
    freeifaddrs(ifa_list);
    return wifiOBytes;
}
+(uint32_t)WiFiInputFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    uint32_t wifiIBytes = 0;
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiIBytes += if_data->ifi_ibytes;
        }
    }
    freeifaddrs(ifa_list);
    return wifiIBytes;
}
+(uint32_t)WiFiAllFlow{
    struct ifaddrs *ifa_list = 0, *ifa;
    if (getifaddrs(&ifa_list) == -1)
    {
        return -1;
    }
    
    uint32_t wifiIBytes = 0;
    uint32_t wifiOBytes = 0;
    uint32_t wifiFlow   = 0;
    
    
    for (ifa = ifa_list; ifa; ifa = ifa->ifa_next)
    {
        if (AF_LINK != ifa->ifa_addr->sa_family)
            continue;
        
        if (!(ifa->ifa_flags & IFF_UP) && !(ifa->ifa_flags & IFF_RUNNING))
            continue;
        
        if (ifa->ifa_data == 0)
            continue;
        
        //wifi flow
        if (!strcmp(ifa->ifa_name, "en0"))
        {
            struct if_data *if_data = (struct if_data *)ifa->ifa_data;
            
            wifiIBytes += if_data->ifi_ibytes;
            wifiOBytes += if_data->ifi_obytes;
            wifiFlow    = wifiIBytes + wifiOBytes;
        }
    }
    freeifaddrs(ifa_list);
    return wifiFlow;
}
+ (long long)DiskSpaceFree{
    struct statfs buf;
    long long freespace;
    freespace = 0;
    if(statfs("/private/var", &buf) >= 0){
        freespace = (long long)buf.f_bsize * buf.f_bfree;
    }
    return freespace;
}
+ (long long)DiskSpaceTotal{
    struct statfs buf;
    long long totalspace;
    totalspace = 0;
    if(statfs("/private/var", &buf) >= 0){
        totalspace = (long long)buf.f_bsize * buf.f_blocks;
    }
    return totalspace;
}
+ (NSUInteger)memoryBytesFree
{
    mach_port_t           host_port = mach_host_self();
    mach_msg_type_number_t   host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);
    vm_size_t               pagesize;
    vm_statistics_data_t     vm_stat;
    host_page_size(host_port, &pagesize);
    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&vm_stat, &host_size) != KERN_SUCCESS) NSLog(@"Failed to fetch vm statistics");
    natural_t   mem_free = vm_stat.free_count * pagesize;
    return mem_free;
}
+ (NSUInteger)memoryBytesTotal{
    return [self getSysInfo:HW_PHYSMEM];
}
+ (NSArray *)CPUUsage{
    NSMutableArray *usage = [NSMutableArray array];
    
    processor_info_array_t _cpuInfo, _prevCPUInfo = nil;
    mach_msg_type_number_t _numCPUInfo, _numPrevCPUInfo = 0;
    unsigned _numCPUs;
    NSLock *_cpuUsageLock;
    
    int _mib[2U] = { CTL_HW, HW_NCPU };
    size_t _sizeOfNumCPUs = sizeof(_numCPUs);
    int _status = sysctl(_mib, 2U, &_numCPUs, &_sizeOfNumCPUs, NULL, 0U);
    if(_status)
        _numCPUs = 1;
    
    _cpuUsageLock = [[NSLock alloc] init];
    
    natural_t _numCPUsU = 0U;
    kern_return_t err = host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &_numCPUsU, &_cpuInfo, &_numCPUInfo);
    if(err == KERN_SUCCESS) {
        [_cpuUsageLock lock];
        
        for(unsigned i = 0U; i < _numCPUs; ++i) {
            Float32 _inUse, _total;
            if(_prevCPUInfo) {
                _inUse = (
                          (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER]   - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER])
                          + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM])
                          + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE]   - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE])
                          );
                _total = _inUse + (_cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE] - _prevCPUInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE]);
            } else {
                _inUse = _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_USER] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_SYSTEM] + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_NICE];
                _total = _inUse + _cpuInfo[(CPU_STATE_MAX * i) + CPU_STATE_IDLE];
            }
            
            float u = _inUse / _total * 100.f;
            [usage addObject:[NSNumber numberWithFloat:u]];
        }
        
        [_cpuUsageLock unlock];
        
        if(_prevCPUInfo) {
            size_t prevCpuInfoSize = sizeof(integer_t) * _numPrevCPUInfo;
            vm_deallocate(mach_task_self(), (vm_address_t)_prevCPUInfo, prevCpuInfoSize);
        }
        
        _prevCPUInfo = _cpuInfo;
        _numPrevCPUInfo = _numCPUInfo;
        
        _cpuInfo = nil;
        _numCPUInfo = 0U;
    } else {
        //NSLog(@"Error!");
    }
    return usage;
}
+ (NSUInteger) getSysInfo: (uint) typeSpecifier
{
    size_t size = sizeof(int);
    int results;
    int mib[2] = {CTL_HW, typeSpecifier};
    sysctl(mib, 2, &results, &size, NULL, 0);
    return (NSUInteger) results;
}
+ (NSUInteger)CPUCount{
    return [self getSysInfo:HW_NCPU];
}
+ (NSString *)CPUFrequency{
    switch ([self platformType])
    {
        case UIDevice3GiPhone: return IPHONE_3G_CPUFREQUENCY;
        case UIDevice3GSiPhone: return IPHONE_3GS_CPUFREQUENCY;
        case UIDevice4iPhone: return IPHONE_4_CPUFREQUENCY;
        case UIDevice4SiPhone: return IPHONE_4S_CPUFREQUENCY;
        case UIDevice5iPhone: return IPHONE_5_CPUFREQUENCY;
        case UIDevice4GiPod: return IPOD_4G_CPUFREQUENCY;
        case UIDevice5GiPod: return IPOD_5G_CPUFREQUENCY;
        case UIDevice1GiPad: return IPAD_1G_CPUFREQUENCY;
        case UIDevice2GiPad: return IPAD_2G_CPUFREQUENCY;
        case UIDevice3GiPad: return IPAD_3G_CPUFREQUENCY;
        case UIDevice4GiPad: return IPAD_4G_CPUFREQUENCY;
        default: return IOS_CPUFREQUENCY_UNKNOWN;
    }
    
}
+ (NSString *) productName
{
    NSString *platform = [self platformInfo];
    
    // The ever mysterious iFPGA
    if ([platform isEqualToString:@"iFPGA"])        return @"iFPGA";
    
    // iPhone
    if ([platform isEqualToString:@"iPhone1,1"])    return IPHONE_1G_NAMESTRING;
    if ([platform isEqualToString:@"iPhone1,2"])    return IPHONE_3G_NAMESTRING;
    if ([platform hasPrefix:@"iPhone2"])            return IPHONE_3GS_NAMESTRING;
    if ([platform hasPrefix:@"iPhone3"])            return IPHONE_4_NAMESTRING;
    if ([platform hasPrefix:@"iPhone4"])            return IPHONE_4S_NAMESTRING;
    if ([platform hasPrefix:@"iPhone5"])            return IPHONE_5_NAMESTRING;
    
    // iPod
    if ([platform hasPrefix:@"iPod1"])              return IPOD_1G_NAMESTRING;
    if ([platform hasPrefix:@"iPod2"])              return IPOD_2G_NAMESTRING;
    if ([platform hasPrefix:@"iPod3"])              return IPOD_3G_NAMESTRING;
    if ([platform hasPrefix:@"iPod4"])              return IPOD_4G_NAMESTRING;
    if ([platform hasPrefix:@"iPod5"])              return IPOD_5G_NAMESTRING;
    
    // iPad
    if ([platform hasPrefix:@"iPad1"])              return IPAD_1G_NAMESTRING;
    if ([platform hasPrefix:@"iPad2"])              return IPAD_2G_NAMESTRING;
    if ([platform hasPrefix:@"iPad3"])              return IPAD_3G_NAMESTRING;
    if ([platform hasPrefix:@"iPad4"])              return IPAD_4G_NAMESTRING;
    
    // Apple TV
    if ([platform hasPrefix:@"AppleTV2"])           return @"Unknown";
    if ([platform hasPrefix:@"AppleTV3"])           return @"Unknown";
    
    if ([platform hasPrefix:@"iPhone"])             return @"Unknown iPhone";
    if ([platform hasPrefix:@"iPod"])               return @"Unknown iPod";
    if ([platform hasPrefix:@"iPad"])               return @"Unknown iPad";
    if ([platform hasPrefix:@"AppleTV"])            return @"Unknown";
    
    
    return @"Unknown";
}
+ (NSUInteger) platformType
{
    NSString *platform = [self platformInfo];
    
    // The ever mysterious iFPGA
    if ([platform isEqualToString:@"iFPGA"])        return UIDeviceIFPGA;
    
    // iPhone
    if ([platform isEqualToString:@"iPhone1,1"])    return UIDevice1GiPhone;
    if ([platform isEqualToString:@"iPhone1,2"])    return UIDevice3GiPhone;
    if ([platform hasPrefix:@"iPhone2"])            return UIDevice3GSiPhone;
    if ([platform hasPrefix:@"iPhone3"])            return UIDevice4iPhone;
    if ([platform hasPrefix:@"iPhone4"])            return UIDevice4SiPhone;
    if ([platform hasPrefix:@"iPhone5"])            return UIDevice5iPhone;
    
    // iPod
    if ([platform hasPrefix:@"iPod1"])              return UIDevice1GiPod;
    if ([platform hasPrefix:@"iPod2"])              return UIDevice2GiPod;
    if ([platform hasPrefix:@"iPod3"])              return UIDevice3GiPod;
    if ([platform hasPrefix:@"iPod4"])              return UIDevice4GiPod;
    if ([platform hasPrefix:@"iPod5"])              return UIDevice5GiPod;
    
    // iPad
    if ([platform hasPrefix:@"iPad1"])              return UIDevice1GiPad;
    if ([platform hasPrefix:@"iPad2"])              return UIDevice2GiPad;
    if ([platform hasPrefix:@"iPad3"])              return UIDevice3GiPad;
    if ([platform hasPrefix:@"iPad4"])              return UIDevice4GiPad;
    
    // Apple TV
    if ([platform hasPrefix:@"AppleTV2"])           return UIDeviceAppleTV2;
    if ([platform hasPrefix:@"AppleTV3"])           return UIDeviceAppleTV3;
    
    if ([platform hasPrefix:@"iPhone"])             return UIDeviceUnknowniPhone;
    if ([platform hasPrefix:@"iPod"])               return UIDeviceUnknowniPod;
    if ([platform hasPrefix:@"iPad"])               return UIDeviceUnknowniPad;
    if ([platform hasPrefix:@"AppleTV"])            return UIDeviceUnknownAppleTV;
    
    // Simulator thanks Jordan Breeding
    if ([platform hasSuffix:@"86"] || [platform isEqual:@"x86_64"])
    {
        BOOL smallerScreen = [[UIScreen mainScreen] bounds].size.width < 768;
        return smallerScreen ? UIDeviceSimulatoriPhone : UIDeviceSimulatoriPad;
    }
    
    return UIDeviceUnknown;
}
+ (NSString *)CPUType
{
    switch ([self platformType])
    {
        case UIDevice3GiPhone: return IPHONE_3G_CPUTYPE;
        case UIDevice3GSiPhone: return IPHONE_3GS_CPUTYPE;
        case UIDevice4iPhone: return IPHONE_4_CPUTYPE;
        case UIDevice4SiPhone: return IPHONE_4S_CPUTYPE;
        case UIDevice5iPhone: return IPHONE_5_CPUTYPE;
        case UIDevice4GiPod: return IPOD_4G_CPUTYPE;
        case UIDevice5GiPod: return IPOD_5G_CPUTYPE;
        case UIDevice1GiPad: return IPAD_1G_CPUTYPE;
        case UIDevice2GiPad: return IPAD_2G_CPUTYPE;
        case UIDevice3GiPad: return IPAD_3G_CPUTYPE;
        case UIDevice4GiPad: return IPAD_4G_CPUTYPE;
        default: return IOS_CPUTYPE_UNKNOWN;
    }
}
+ (NSString *) getSysInfoByName:(char *)typeSpecifier
{
    size_t size;
    sysctlbyname(typeSpecifier, NULL, &size, NULL, 0);
    
    char *answer = malloc(size);
    sysctlbyname(typeSpecifier, answer, &size, NULL, 0);
    
    NSString *results = [NSString stringWithCString:answer encoding: NSUTF8StringEncoding];
    
    free(answer);
    return results;
}
+ (NSString *)platformInfo
{
    return [self getSysInfoByName:"hw.machine"];
}

+ (CGFloat)usedDiskSpace{
    return [self folderSizeAtPath:@"/var/mobile/"];
}
+ (NSDictionary*)userApplicationsInfo{
    NSMutableDictionary *applicationsInfo = [[NSMutableDictionary alloc] init];
    NSFileManager *applicationManager = [NSFileManager defaultManager];
    NSMutableArray *appFolders = [[NSMutableArray alloc] init];
    NSError *error = nil;
    NSArray *appsPath = [applicationManager contentsOfDirectoryAtPath:@"/var/mobile/Applications/" error:&error];
    NSMutableArray *appsPaths = [[NSMutableArray alloc] init];
    
    for(NSString *path in appsPath) {
        if([path length] == 36) {
            [appsPaths addObject:[NSString stringWithFormat:@"/var/mobile/Applications/%@/",path]];
        }
    }
    for(NSString *completePath in appsPaths) {
        BOOL isDIR = NO;
        [applicationManager fileExistsAtPath:completePath isDirectory:&isDIR];
        if(isDIR == YES) {
            [appFolders addObject:completePath];
        }
    }
    NSMutableArray *applicationsPaths = [[NSMutableArray alloc] initWithArray:appFolders];
    NSMutableArray *plistArray = [[NSMutableArray alloc] init];
    for(NSString *paths in appFolders) {
        NSArray *singleApp = [applicationManager contentsOfDirectoryAtPath:paths error:&error];
        for(NSString *postfix in singleApp) {
            if([postfix hasSuffix:@".app"]) {
                NSString *plistPath = [NSString stringWithFormat:@"%@%@%@",paths,postfix,@"/Info.plist"];
                if([applicationManager fileExistsAtPath:plistPath]) {
                    [plistArray addObject:plistPath];
                    
                }
            }
        }
    }
    
    NSMutableArray *appName = [[NSMutableArray alloc] init];
    for(NSString *plistFilePath in plistArray) {
        NSDictionary *plistContent = [[NSDictionary alloc] initWithContentsOfFile:plistFilePath];
        if ([[plistContent objectForKey:@"CFBundleDisplayName"] length] == 0) {
            [appName addObject:@""];
        }else{
            [appName addObject:[plistContent objectForKey:@"CFBundleDisplayName"]];
        }
    }
    //name in appName NSMutableArray
    //application path in applicationsPaths NSArray
    [applicationsInfo setObject:appName forKey:@"Application Name"];
    NSInteger i = 0;
    for(NSString *name in appName) {
        NSMutableDictionary *info = [[NSMutableDictionary alloc] init];
        [info setObject:[NSString stringWithFormat:@"%lf",[self folderSizeAtPath:[NSString stringWithFormat:@"%@tmp/",[applicationsPaths objectAtIndex:i]]]] forKey:@"tmp Size"];
        [info setObject:[NSString stringWithFormat:@"%lf",[self folderSizeAtPath:[NSString stringWithFormat:@"%@Documents/",[applicationsPaths objectAtIndex:i]]]] forKey:@"document Size"];
        [info setObject:[NSString stringWithFormat:@"%lf",[self folderSizeAtPath:[NSString stringWithFormat:@"%@/",[applicationsPaths objectAtIndex:i]]]] forKey:@"application Size"];
        [info setObject:[NSString stringWithFormat:@"%@tmp/",[applicationsPaths objectAtIndex:i]] forKey:@"tmp Path"];
        [applicationsInfo setObject:info forKey:name];
        i++;
    }
    return applicationsInfo;
    
}


+ (void)LocalNotificationWithContext:(NSString *)context AfterDelay:(CGFloat)seconds{
    int type =10;
    NSString *alerBody = nil;
    NSDate *fireDate = nil;
    if (type == 10) {
        alerBody = context;
        fireDate = [NSDate dateWithTimeIntervalSinceNow:seconds];
    }
    
    if (fireDate && alerBody)
    {
        UILocalNotification *localNotif = [[UILocalNotification alloc] init];
        localNotif.fireDate = fireDate;
        localNotif.userInfo = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithInt:type],@"GT_API", nil];
        localNotif.timeZone = [NSTimeZone systemTimeZone];
        localNotif.alertBody = alerBody;
        localNotif.soundName = UILocalNotificationDefaultSoundName;
        
        localNotif.applicationIconBadgeNumber = 0;
        [[UIApplication sharedApplication] scheduleLocalNotification:localNotif];
    }
}
+ (NSInteger)BatteryVoltage{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Raw Voltage"] integerValue];
    return result;
}
+ (NSInteger)BatteryLevel{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Level"] integerValue];
    return result;
}
+ (NSInteger)BatteryCurrentCapacity{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Current Capacity"] integerValue];
    return result;
}
+ (NSInteger)BatteryDesignCapacity{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Design Capacity"] integerValue];
    return result;
}
+ (NSInteger)BatteryMaxCapacity{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Max Capacity"] integerValue];
    return result;
}
+ (NSInteger)BatteryCycleCount{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Cycle Count"] integerValue];
    return result;
}
+ (NSInteger)BatteryChargerID{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Charger ID"] integerValue];
    return result;
}
+ (NSInteger)BatteryChargerCurrent{
    NSInteger result = [(NSString *)[[[super alloc] BatteryInfo] objectForKey:@"Charger Current"] integerValue];
    return result;
}
+ (BOOL)BatteryExternalPowerConnected{
    BOOL result = [(NSString*)[[[super alloc] BatteryInfo] objectForKey:@"External Power"] boolValue];
    return result;
}
+ (BOOL)BatteryIsCharging{
    BOOL result = [(NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Device Charging"] boolValue];
    return result;
}
+ (BOOL)BatteryChargerConnected{
    BOOL result = [(NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Device Charger Connected"] boolValue];
    return result;
}
+(BOOL)BatteryExactDeviceChargerConnected{
    BOOL result = [(NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Exact Device Charger"] boolValue];
    return result;
}
+ (NSString *)BatteryID{
    NSString *result = (NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Battery ID"];
    return result;
}
+ (NSString *)BatterySerialNumber{
    NSString *result = (NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Serial Number"];
    return result;
}
+ (NSString *)BatteryChargerType{
    NSString *result = (NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Charger Type"];
    return result;
}
+ (NSString *)BatteryManufacturer{
    NSString *result = (NSString*)[[[super alloc] BatteryInfo] objectForKey:@"Manufacturer"];
    return result;
}
- (NSMutableDictionary *) BatteryInfo {
    NSBundle *b = [NSBundle bundleWithPath:@"/System/Library/PrivateFrameworks/GAIA.framework"];
    BOOL success = [b load];
    
    if (success) {
        Class OSDBattery = NSClassFromString(@"OSDBattery");
        id powerController = [OSDBattery sharedInstance];
        
        NSMutableDictionary *batteryInfo = [NSMutableDictionary dictionary];
        
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getRawBatteryVoltage]] forKey:@"Raw Voltage"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getBatteryLevel]] forKey:@"Level"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getBatteryCurrentCapacity]] forKey:@"Current Capacity"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getBatteryDesignCapacity]] forKey:@"Design Capacity"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getBatteryCycleCount]] forKey:@"Cycle Count"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getChargerID]] forKey:@"Charger ID"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getChargerCurrent]] forKey:@"Charger Current"];
        [batteryInfo setObject:[powerController _externalPowerConnected] ? @"Yes" : @"No" forKey:@"External Power"];
        [batteryInfo setObject:[powerController _deviceIsCharging] ? @"Yes" : @"No"  forKey:@"Device Charging"];
        [batteryInfo setObject:[powerController _deviceChargerConnected] ? @"Yes" : @"No" forKey:@"Device Charger Connected"];
        [batteryInfo setObject:[powerController _exactDeviceChargerConnected] ? @"Yes" : @"No" forKey:@"Exact Device Charger"];
        [batteryInfo setObject:[powerController _batteryID] forKey:@"Battery ID"];
        [batteryInfo setObject:[powerController _getBatterySerialNumber] forKey:@"Serial Number"];
        [batteryInfo setObject:[powerController _getBatteryManufacturer]  forKey:@"Manufacturer"];
        [batteryInfo setObject:[powerController _getChargerType] forKey:@"Charger Type"];
        [batteryInfo setObject:[NSString stringWithFormat:@"%d", [powerController _getBatteryMaxCapacity]] forKey:@"Max Capacity"];
        return batteryInfo;
    }
    return nil;
}
bool is_dir(const char *path)
{
    struct stat statbuf;
    if(lstat(path, &statbuf) ==0)
    {
        return S_ISDIR(statbuf.st_mode) != 0;
    }
    return false;
}
bool is_file(const char *path)
{
    struct stat statbuf;
    if(lstat(path, &statbuf) ==0)
        return S_ISREG(statbuf.st_mode) != 0;
    return false;
}
bool is_special_dir(const char *path)
{
    return strcmp(path, ".") == 0 || strcmp(path, "..") == 0;
}
void get_file_path(const char *path, const char *file_name,  char *file_path)
{
    strcpy(file_path, path);
    if(file_path[strlen(path) - 1] != '/')
        strcat(file_path, "/");
    strcat(file_path, file_name);
}

void delete_file(const char *path)
{
    DIR *dir;
    struct dirent *dir_info;
    char file_path[PATH_MAX];
    if(is_file(path))
    {
        remove(path);
        return;
    }
    if(is_dir(path))
    {
        if((dir = opendir(path)) == NULL)
            return;
        while((dir_info = readdir(dir)) != NULL)
        {
            if(is_special_dir(dir_info->d_name))
                continue;
            get_file_path(path, dir_info->d_name, file_path);
            if(is_dir(file_path))
            {
                delete_file(file_path);
                rmdir(file_path);
            }
            else if(is_file(file_path))
                remove(file_path);
        }
        closedir(dir);
    }
}
CGFloat calcMethodTime (void (^block)(void)) {
    mach_timebase_info_data_t info;
    if (mach_timebase_info(&info) != KERN_SUCCESS) return -1.0;
    
    uint64_t start = mach_absolute_time ();
    block ();
    uint64_t end = mach_absolute_time ();
    uint64_t elapsed = end - start;
    
    uint64_t nanos = elapsed * info.numer / info.denom;
    return (CGFloat)nanos / NSEC_PER_SEC;
}
+ (CGFloat) folderSizeAtPath: (NSString *)folderPath{
    const char * folderpath = [folderPath UTF8String];
    long long folderSize = 0;
    DIR* dir = opendir(folderpath);
    if (dir == NULL) return 0;
    struct dirent* child;
    while ((child = readdir(dir))!=NULL) {
        if (child->d_type == DT_DIR && ((child->d_name[0] == '.' && child->d_name[1] == 0) || (child->d_name[0] == '.' && child->d_name[1] == '.' && child->d_name[2] == 0)))continue;
        int folderPathLength = strlen(folderpath);
        char childPath[1536];
        stpcpy(childPath, folderpath);
        if (folderpath[folderPathLength-1] != '/'){
            childPath[folderPathLength] = '/';
            folderPathLength++;
        }
        stpcpy(childPath+folderPathLength, child->d_name);
        childPath[folderPathLength + child->d_namlen] = 0;
        if (child->d_type == DT_DIR){
            folderSize += [self folderSizeAtPath:[NSString stringWithUTF8String:childPath]];
            struct stat st;
            if(lstat(childPath, &st) == 0) folderSize += st.st_size;
        }else if (child->d_type == DT_REG || child->d_type == DT_LNK){
            struct stat st;
            if(lstat(childPath, &st) == 0) folderSize += st.st_size;
        }
    }
    return folderSize;
}

+ (void)Clean_tmp{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    NSArray *fileList = [[NSArray alloc] init];
    NSMutableArray *dirArray = [[NSMutableArray alloc] init];//NSString MArray
    BOOL isDir = NO;
    fileList = [fileManager contentsOfDirectoryAtPath:kApp_Path error:&error];
    for (NSString *file in fileList) {
        NSString *path = [kApp_Path stringByAppendingPathComponent:file];
        [fileManager fileExistsAtPath:path isDirectory:(&isDir)];
        if (isDir) {
            [dirArray addObject:file];
        }
        isDir = NO;
    }
    long long fileSize = 0;
    const char *path;
    NSMutableArray *tmpDirArray = [[NSMutableArray alloc] init];//NSString MArray
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/tmp/",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [tmpDirArray addObject:[NSString stringWithFormat:@"%@",name]];
        path = [name UTF8String];
        fileSize += [self folderSizeAtPath:[NSString stringWithUTF8String:path]];
    }
    NSArray *tmp1 = [[NSArray alloc] init];
    NSError *fileError = nil;
    
    NSNumber *releaseSize;
    NSDictionary *attributes = [[NSDictionary alloc]init];
    for (int i=0; i<[tmpDirArray count]; i++) {
        NSString *srcPath = [tmpDirArray objectAtIndex:(NSUInteger)i];
        tmp1 = [fileManager contentsOfDirectoryAtPath:srcPath error:&fileError];
        
        for(NSString *file in tmp1){
            NSString *path = [[tmpDirArray objectAtIndex:(NSUInteger)i] stringByAppendingPathComponent:file];
            if([fileManager fileExistsAtPath:path]){
                attributes = [fileManager attributesOfItemAtPath:path error:nil];
                releaseSize = [attributes objectForKey:NSFileSize];
                fileSize += [releaseSize intValue];
                
                [fileManager removeItemAtPath:path error:&error];
            }
        }
    }
    if (fileSize < 1024 * 1024) {
        if (fileSize <= 1000) {
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:@"tmp文件夹下非常干净\n无须清理哦" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
            [alert show];
            
            
            return;
        }
        NSString *showReleaseSize = [NSString stringWithFormat:@"tmp文件夹已经清理完毕～\n本次释放%.2fKB空间",fileSize / 1024.0];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }else{
        double convertToMB = 0.0;
        convertToMB = fileSize / 1024.0;
        convertToMB = convertToMB / 1024.0;
        
        NSString *showReleaseSize = [NSString stringWithFormat:@"tmp文件夹已经清理完毕～\n本次释放%.2fMB空间",convertToMB];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }
}
+ (void)Clean_Cache{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    
    NSError *error = nil;
    NSArray *fileList = [[NSArray alloc] init];
    NSMutableArray *dirArray = [[NSMutableArray alloc] init];//NSString MArray
    BOOL isDir = NO;
    BOOL isDontClean = NO;
    
    fileList = [fileManager contentsOfDirectoryAtPath:kApp_Path error:&error];
    for (NSString *file in fileList) {
        NSString *path = [kApp_Path stringByAppendingPathComponent:file];
        [fileManager fileExistsAtPath:path isDirectory:(&isDir)];
        if (isDir) {
            [dirArray addObject:file];
        }
        isDir = NO;
    }
    
    
    NSMutableArray *tmpDirArray = [[NSMutableArray alloc] init];//NSString MArray
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/Library/Caches/",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        
        NSString *youdao = [NSString stringWithFormat:@"%@/%@/YoudaoDictPro.app",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        NSString *powerWord = [NSString stringWithFormat:@"%@/%@/PowerWord3.app",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [fileManager fileExistsAtPath:youdao isDirectory:(&isDontClean)];
        
        if (isDontClean) {
        }
        else if(1==1){
            [fileManager fileExistsAtPath:powerWord isDirectory:(&isDontClean)];
            if (isDontClean) {
                
            }else{
                [tmpDirArray addObject:[NSString stringWithFormat:@"%@",name]];
            }
        }
        isDontClean = NO;
        
    }
    
    
    
    NSArray *tmp1 = [[NSArray alloc] init];
    NSError *fileError = nil;
    NSNumber *releaseSize;
    int fileSize = 0;
    NSDictionary *attributes = [[NSDictionary alloc]init];
    for (int i=0; i<[tmpDirArray count]; i++) {
        NSString *srcPath = [tmpDirArray objectAtIndex:(NSUInteger)i];
        tmp1 = [fileManager contentsOfDirectoryAtPath:srcPath error:&fileError];
        
        for(NSString *file in tmp1){
            NSString *path = [[tmpDirArray objectAtIndex:(NSUInteger)i] stringByAppendingPathComponent:file];
            if([fileManager fileExistsAtPath:path]){
                attributes = [fileManager attributesOfItemAtPath:path error:nil];
                releaseSize = [attributes objectForKey:NSFileSize];
                fileSize += [releaseSize intValue];
                
                [fileManager removeItemAtPath:path error:&error];
            }
        }
    }
    
    
    if (fileSize < 1024 * 1024) {
        if (fileSize <= 10) {
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:@"Caches文件夹下非常干净\n无须清理哦" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
            [alert show];
            
            return;
        }
        NSString *showReleaseSize = [NSString stringWithFormat:@"Caches文件夹已经清理完毕～\n本次释放%.2fKB空间",fileSize / 1024.0];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }else{
        double convertToMB = 0.0;
        convertToMB = fileSize / 1024.0;
        convertToMB = convertToMB / 1024.0;
        
        NSString *showReleaseSize = [NSString stringWithFormat:@"Caches文件夹已经清理完毕～\n本次释放%.2fMB空间",convertToMB];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }
}
+ (void)Clean_Artwork{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    
    NSError *error = nil;
    NSArray *fileList = [[NSArray alloc] init];
    NSMutableArray *dirArray = [[NSMutableArray alloc] init];//NSString MArray
    BOOL isDir = NO;
    
    
    fileList = [fileManager contentsOfDirectoryAtPath:kApp_Path error:&error];
    for (NSString *file in fileList) {
        NSString *path = [kApp_Path stringByAppendingPathComponent:file];
        [fileManager fileExistsAtPath:path isDirectory:(&isDir)];
        if (isDir) {
            [dirArray addObject:file];
        }
        isDir = NO;
    }
    NSNumber *releaseSize;
    int fileSize = 0;
    NSDictionary *attributes = [[NSDictionary alloc]init];
    NSMutableArray *tmpDirArray = [[NSMutableArray alloc] init];//NSString MArray
    
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/iTunesArtwork",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [tmpDirArray addObject:[NSString stringWithFormat:@"%@",name]];
        
        
    }
    
    
    
    
    for (int i=0; i<[tmpDirArray count]; i++) {
        NSString *srcPath = [tmpDirArray objectAtIndex:(NSUInteger)i];
        if([fileManager fileExistsAtPath:srcPath]){
            
            attributes = [fileManager attributesOfItemAtPath:srcPath error:nil];
            releaseSize = [attributes objectForKey:NSFileSize];
            fileSize += [releaseSize intValue];
            
            [fileManager removeItemAtPath:srcPath error:&error];
        }
    }
    if (fileSize < 1024 * 1024) {
        if (fileSize <= 10) {
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:@"没有找到任何iTunesArtwork文件\n无须清理哦" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
            [alert show];
            
            return;
        }
        NSString *showReleaseSize = [NSString stringWithFormat:@"iTunesArtwork文件已经清理完毕～\n本次释放%.2fKB空间",fileSize / 1024.0];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }else{
        double convertToMB = 0.0;
        convertToMB = fileSize / 1024.0;
        convertToMB = convertToMB / 1024.0;
        
        NSString *showReleaseSize = [NSString stringWithFormat:@"iTunesArtwork文件已经清理完毕～\n本次释放%.2fMB空间",convertToMB];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }
}
+ (void)Clean_All{
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    
    NSError *error = nil;
    NSArray *fileList = [[NSArray alloc] init];
    NSMutableArray *dirArray = [[NSMutableArray alloc] init];//NSString MArray
    BOOL isDir = NO;
    BOOL isDontClean = NO;
    
    
    fileList = [fileManager contentsOfDirectoryAtPath:kApp_Path error:&error];
    for (NSString *file in fileList) {
        NSString *path = [kApp_Path stringByAppendingPathComponent:file];
        [fileManager fileExistsAtPath:path isDirectory:(&isDir)];
        if (isDir) {
            [dirArray addObject:file];
        }
        isDir = NO;
    }
    
    
    NSMutableArray *tmpDirArray = [[NSMutableArray alloc] init];//NSString MArray
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/Library/Caches/",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        
        NSString *youdao = [NSString stringWithFormat:@"%@/%@/YoudaoDictPro.app",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [fileManager fileExistsAtPath:youdao isDirectory:(&isDontClean)];
        if (isDontClean) {
            //[dirArray addObject:file];
        }
        else {
            [tmpDirArray addObject:[NSString stringWithFormat:@"%@",name]];
        }
        isDontClean = NO;
        
        
    }
    
    NSArray *tmp1 = [[NSArray alloc] init];
    NSError *fileError = nil;
    NSNumber *releaseSize;
    int fileSize = 0;
    NSDictionary *attributes = [[NSDictionary alloc]init];
    for (int i=0; i<[tmpDirArray count]; i++) {
        NSString *srcPath = [tmpDirArray objectAtIndex:(NSUInteger)i];
        tmp1 = [fileManager contentsOfDirectoryAtPath:srcPath error:&fileError];
        
        for(NSString *file in tmp1){
            NSString *path = [[tmpDirArray objectAtIndex:(NSUInteger)i] stringByAppendingPathComponent:file];
            if([fileManager fileExistsAtPath:path]){
                attributes = [fileManager attributesOfItemAtPath:path error:nil];
                releaseSize = [attributes objectForKey:NSFileSize];
                fileSize += [releaseSize intValue];
                [fileManager removeItemAtPath:path error:&error];
            }
        }
    }
    
    
    NSMutableArray *tmpDirArray1 = [[NSMutableArray alloc] init];//NSString MArray
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/tmp/",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [tmpDirArray1 addObject:[NSString stringWithFormat:@"%@",name]];
        
    }
    
    
    
    NSArray *tmp11 = [[NSArray alloc] init];
    NSError *fileError1 = nil;
    
    for (int i=0; i<[tmpDirArray1 count]; i++) {
        NSString *srcPath = [tmpDirArray1 objectAtIndex:(NSUInteger)i];
        tmp11 = [fileManager contentsOfDirectoryAtPath:srcPath error:&fileError1];
        
        for(NSString *file in tmp11){
            NSString *path = [[tmpDirArray1 objectAtIndex:(NSUInteger)i] stringByAppendingPathComponent:file];
            if([fileManager fileExistsAtPath:path]){
                attributes = [fileManager attributesOfItemAtPath:path error:nil];
                releaseSize = [attributes objectForKey:NSFileSize];
                fileSize += [releaseSize intValue];
                [fileManager removeItemAtPath:path error:&error];
            }
        }
        
    }
    
    NSMutableArray *tmpDirArray2 = [[NSMutableArray alloc] init];//NSString MArray
    
    for (int i=0; i<[dirArray count]; i++) {
        NSString *name = [NSString stringWithFormat:@"%@/%@/iTunesArtwork",kApp_Path,[dirArray objectAtIndex:(NSUInteger)i]];
        [tmpDirArray2 addObject:[NSString stringWithFormat:@"%@",name]];
        
        
    }
    
    
    
    
    for (int i=0; i<[tmpDirArray2 count]; i++) {
        NSString *srcPath = [tmpDirArray2 objectAtIndex:(NSUInteger)i];
        if([fileManager fileExistsAtPath:srcPath]){
            
            attributes = [fileManager attributesOfItemAtPath:srcPath error:nil];
            releaseSize = [attributes objectForKey:NSFileSize];
            fileSize += [releaseSize intValue];
            
            [fileManager removeItemAtPath:srcPath error:&error];
        }
    }
    
    
    if (fileSize < 1024 * 1024) {
        if (fileSize == 0) {
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:@"没有找到任何不需要的文件\n无须清理哦" delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
            [alert show];
            
            return;
        }
        NSString *showReleaseSize = [NSString stringWithFormat:@"所有缓存及临时文件已经清理完毕～\n本次释放%.2fKB空间",fileSize / 1024.0];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }else{
        double convertToMB = 0.0;
        convertToMB = fileSize / 1024.0;
        convertToMB = convertToMB / 1024.0;
        
        NSString *showReleaseSize = [NSString stringWithFormat:@"所有缓存及临时文件已经清理完毕～\n本次释放%.2fMB空间",convertToMB];
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Clear Up!" message:showReleaseSize delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil, nil];
        [alert show];
        
    }
}

@end
